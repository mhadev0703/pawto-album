"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadResourceModel = exports.mangleLikeCloudFormation = exports.unionOf = exports.diffKeyedEntities = exports.deepEqual = void 0;
const aws_service_spec_1 = require("@aws-cdk/aws-service-spec");
/**
 * Compares two objects for equality, deeply. The function handles arguments that are
 * +null+, +undefined+, arrays and objects. For objects, the function will not take the
 * object prototype into account for the purpose of the comparison, only the values of
 * properties reported by +Object.keys+.
 *
 * If both operands can be parsed to equivalent numbers, will return true.
 * This makes diff consistent with CloudFormation, where a numeric 10 and a literal "10"
 * are considered equivalent.
 *
 * @param lvalue the left operand of the equality comparison.
 * @param rvalue the right operand of the equality comparison.
 *
 * @returns +true+ if both +lvalue+ and +rvalue+ are equivalent to each other.
 */
function deepEqual(lvalue, rvalue) {
    if (lvalue === rvalue) {
        return true;
    }
    // CloudFormation allows passing strings into boolean-typed fields
    if (((typeof lvalue === 'string' && typeof rvalue === 'boolean') ||
        (typeof lvalue === 'boolean' && typeof rvalue === 'string')) &&
        lvalue.toString() === rvalue.toString()) {
        return true;
    }
    // allows a numeric 10 and a literal "10" to be equivalent;
    // this is consistent with CloudFormation.
    if ((typeof lvalue === 'string' || typeof rvalue === 'string') &&
        safeParseFloat(lvalue) === safeParseFloat(rvalue)) {
        return true;
    }
    if (typeof lvalue !== typeof rvalue) {
        return false;
    }
    if (Array.isArray(lvalue) !== Array.isArray(rvalue)) {
        return false;
    }
    if (Array.isArray(lvalue) /* && Array.isArray(rvalue) */) {
        if (lvalue.length !== rvalue.length) {
            return false;
        }
        for (let i = 0; i < lvalue.length; i++) {
            if (!deepEqual(lvalue[i], rvalue[i])) {
                return false;
            }
        }
        return true;
    }
    if (typeof lvalue === 'object' /* && typeof rvalue === 'object' */) {
        if (lvalue === null || rvalue === null) {
            // If both were null, they'd have been ===
            return false;
        }
        const keys = Object.keys(lvalue);
        if (keys.length !== Object.keys(rvalue).length) {
            return false;
        }
        for (const key of keys) {
            if (!rvalue.hasOwnProperty(key)) {
                return false;
            }
            if (key === 'DependsOn') {
                if (!dependsOnEqual(lvalue[key], rvalue[key])) {
                    return false;
                }
                ;
                // check differences other than `DependsOn`
                continue;
            }
            if (!deepEqual(lvalue[key], rvalue[key])) {
                return false;
            }
        }
        return true;
    }
    // Neither object, nor array: I deduce this is primitive type
    // Primitive type and not ===, so I deduce not deepEqual
    return false;
}
exports.deepEqual = deepEqual;
/**
 * Compares two arguments to DependsOn for equality.
 *
 * @param lvalue the left operand of the equality comparison.
 * @param rvalue the right operand of the equality comparison.
 *
 * @returns +true+ if both +lvalue+ and +rvalue+ are equivalent to each other.
 */
function dependsOnEqual(lvalue, rvalue) {
    // allows ['Value'] and 'Value' to be equal
    if (Array.isArray(lvalue) !== Array.isArray(rvalue)) {
        const array = Array.isArray(lvalue) ? lvalue : rvalue;
        const nonArray = Array.isArray(lvalue) ? rvalue : lvalue;
        if (array.length === 1 && deepEqual(array[0], nonArray)) {
            return true;
        }
        return false;
    }
    // allows arrays passed to DependsOn to be equivalent irrespective of element order
    if (Array.isArray(lvalue) && Array.isArray(rvalue)) {
        if (lvalue.length !== rvalue.length) {
            return false;
        }
        for (let i = 0; i < lvalue.length; i++) {
            for (let j = 0; j < lvalue.length; j++) {
                if ((!deepEqual(lvalue[i], rvalue[j])) && (j === lvalue.length - 1)) {
                    return false;
                }
                break;
            }
        }
        return true;
    }
    return false;
}
/**
 * Produce the differences between two maps, as a map, using a specified diff function.
 *
 * @param oldValue  the old map.
 * @param newValue  the new map.
 * @param elementDiff the diff function.
 *
 * @returns a map representing the differences between +oldValue+ and +newValue+.
 */
function diffKeyedEntities(oldValue, newValue, elementDiff) {
    const result = {};
    for (const logicalId of unionOf(Object.keys(oldValue || {}), Object.keys(newValue || {}))) {
        const oldElement = oldValue && oldValue[logicalId];
        const newElement = newValue && newValue[logicalId];
        if (oldElement === undefined && newElement === undefined) {
            // Shouldn't happen in reality, but may happen in tests. Skip.
            continue;
        }
        result[logicalId] = elementDiff(oldElement, newElement, logicalId);
    }
    return result;
}
exports.diffKeyedEntities = diffKeyedEntities;
/**
 * Computes the union of two sets of strings.
 *
 * @param lv the left set of strings.
 * @param rv the right set of strings.
 *
 * @returns a new array containing all elemebts from +lv+ and +rv+, with no duplicates.
 */
function unionOf(lv, rv) {
    const result = new Set(lv);
    for (const v of rv) {
        result.add(v);
    }
    return new Array(...result);
}
exports.unionOf = unionOf;
/**
 * GetStackTemplate flattens any codepoint greater than "\u7f" to "?". This is
 * true even for codepoints in the supplemental planes which are represented
 * in JS as surrogate pairs, all the way up to "\u{10ffff}".
 *
 * This function implements the same mangling in order to provide diagnostic
 * information in `cdk diff`.
 */
function mangleLikeCloudFormation(payload) {
    return payload.replace(/[\u{80}-\u{10ffff}]/gu, '?');
}
exports.mangleLikeCloudFormation = mangleLikeCloudFormation;
/**
 * A parseFloat implementation that does the right thing for
 * strings like '0.0.0'
 * (for which JavaScript's parseFloat() returns 0).
 * We return NaN for all of these strings that do not represent numbers,
 * and so comparing them fails,
 * and doesn't short-circuit the diff logic.
 */
function safeParseFloat(str) {
    return Number(str);
}
/**
 * Lazily load the service spec database and cache the loaded db
*/
let DATABASE;
function database() {
    if (!DATABASE) {
        DATABASE = (0, aws_service_spec_1.loadAwsServiceSpecSync)();
    }
    return DATABASE;
}
/**
 * Load a Resource model from the Service Spec Database
 *
 * The database is loaded lazily and cached across multiple calls to `loadResourceModel`.
 */
function loadResourceModel(type) {
    return database().lookup('resource', 'cloudFormationType', 'equals', type).at(0);
}
exports.loadResourceModel = loadResourceModel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsZ0VBQW1FO0FBR25FOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLE1BQVcsRUFBRSxNQUFXO0lBQ2hELElBQUksTUFBTSxLQUFLLE1BQU0sRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDO0tBQUU7SUFDdkMsa0VBQWtFO0lBQ2xFLElBQUksQ0FBQyxDQUFDLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLE1BQU0sS0FBSyxTQUFTLENBQUM7UUFDNUQsQ0FBQyxPQUFPLE1BQU0sS0FBSyxTQUFTLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxDQUFDLENBQUM7UUFDNUQsTUFBTSxDQUFDLFFBQVEsRUFBRSxLQUFLLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRTtRQUMzQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsMkRBQTJEO0lBQzNELDBDQUEwQztJQUMxQyxJQUFJLENBQUMsT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQztRQUMxRCxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ3JELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxFQUFFO1FBQUUsT0FBTyxLQUFLLENBQUM7S0FBRTtJQUN0RCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUFFLE9BQU8sS0FBSyxDQUFDO0tBQUU7SUFDdEUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLDhCQUE4QixFQUFFO1FBQ3hELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFB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RUFBMEI7SUFDNUUsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDM0IsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNmO0lBQ0QsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFORCwwQkFNQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxPQUFlO0lBQ3RELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN2RCxDQUFDO0FBRkQsNERBRUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBUyxjQUFjLENBQUMsR0FBVztJQUNqQyxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyQixDQUFDO0FBRUQ7O0VBRUU7QUFDRixJQUFJLFFBQWtDLENBQUM7QUFDdkMsU0FBUyxRQUFRO0lBQ2YsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNiLFFBQVEsR0FBRyxJQUFBLHlDQUFzQixHQUFFLENBQUM7S0FDckM7SUFDRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLGlCQUFpQixDQUFDLElBQVk7SUFDNUMsT0FBTyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkYsQ0FBQztBQUZELDhDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbG9hZEF3c1NlcnZpY2VTcGVjU3luYyB9IGZyb20gJ0Bhd3MtY2RrL2F3cy1zZXJ2aWNlLXNwZWMnO1xuaW1wb3J0IHsgUmVzb3VyY2UsIFNwZWNEYXRhYmFzZSB9IGZyb20gJ0Bhd3MtY2RrL3NlcnZpY2Utc3BlYy10eXBlcyc7XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIG9iamVjdHMgZm9yIGVxdWFsaXR5LCBkZWVwbHkuIFRoZSBmdW5jdGlvbiBoYW5kbGVzIGFyZ3VtZW50cyB0aGF0IGFyZVxuICogK251bGwrLCArdW5kZWZpbmVkKywgYXJyYXlzIGFuZCBvYmplY3RzLiBGb3Igb2JqZWN0cywgdGhlIGZ1bmN0aW9uIHdpbGwgbm90IHRha2UgdGhlXG4gKiBvYmplY3QgcHJvdG90eXBlIGludG8gYWNjb3VudCBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbXBhcmlzb24sIG9ubHkgdGhlIHZhbHVlcyBvZlxuICogcHJvcGVydGllcyByZXBvcnRlZCBieSArT2JqZWN0LmtleXMrLlxuICpcbiAqIElmIGJvdGggb3BlcmFuZHMgY2FuIGJlIHBhcnNlZCB0byBlcXVpdmFsZW50IG51bWJlcnMsIHdpbGwgcmV0dXJuIHRydWUuXG4gKiBUaGlzIG1ha2VzIGRpZmYgY29uc2lzdGVudCB3aXRoIENsb3VkRm9ybWF0aW9uLCB3aGVyZSBhIG51bWVyaWMgMTAgYW5kIGEgbGl0ZXJhbCBcIjEwXCJcbiAqIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQuXG4gKlxuICogQHBhcmFtIGx2YWx1ZSB0aGUgbGVmdCBvcGVyYW5kIG9mIHRoZSBlcXVhbGl0eSBjb21wYXJpc29uLlxuICogQHBhcmFtIHJ2YWx1ZSB0aGUgcmlnaHQgb3BlcmFuZCBvZiB0aGUgZXF1YWxpdHkgY29tcGFyaXNvbi5cbiAqXG4gKiBAcmV0dXJucyArdHJ1ZSsgaWYgYm90aCArbHZhbHVlKyBhbmQgK3J2YWx1ZSsgYXJlIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFcXVhbChsdmFsdWU6IGFueSwgcnZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKGx2YWx1ZSA9PT0gcnZhbHVlKSB7IHJldHVybiB0cnVlOyB9XG4gIC8vIENsb3VkRm9ybWF0aW9uIGFsbG93cyBwYXNzaW5nIHN0cmluZ3MgaW50byBib29sZWFuLXR5cGVkIGZpZWxkc1xuICBpZiAoKCh0eXBlb2YgbHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgcnZhbHVlID09PSAnYm9vbGVhbicpIHx8XG4gICAgICAodHlwZW9mIGx2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiBydmFsdWUgPT09ICdzdHJpbmcnKSkgJiZcbiAgICAgIGx2YWx1ZS50b1N0cmluZygpID09PSBydmFsdWUudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGFsbG93cyBhIG51bWVyaWMgMTAgYW5kIGEgbGl0ZXJhbCBcIjEwXCIgdG8gYmUgZXF1aXZhbGVudDtcbiAgLy8gdGhpcyBpcyBjb25zaXN0ZW50IHdpdGggQ2xvdWRGb3JtYXRpb24uXG4gIGlmICgodHlwZW9mIGx2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJ2YWx1ZSA9PT0gJ3N0cmluZycpICYmXG4gICAgICBzYWZlUGFyc2VGbG9hdChsdmFsdWUpID09PSBzYWZlUGFyc2VGbG9hdChydmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBsdmFsdWUgIT09IHR5cGVvZiBydmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChBcnJheS5pc0FycmF5KGx2YWx1ZSkgIT09IEFycmF5LmlzQXJyYXkocnZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobHZhbHVlKSAvKiAmJiBBcnJheS5pc0FycmF5KHJ2YWx1ZSkgKi8pIHtcbiAgICBpZiAobHZhbHVlLmxlbmd0aCAhPT0gcnZhbHVlLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKGxldCBpID0gMCA7IGkgPCBsdmFsdWUubGVuZ3RoIDsgaSsrKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChsdmFsdWVbaV0sIHJ2YWx1ZVtpXSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgbHZhbHVlID09PSAnb2JqZWN0JyAvKiAmJiB0eXBlb2YgcnZhbHVlID09PSAnb2JqZWN0JyAqLykge1xuICAgIGlmIChsdmFsdWUgPT09IG51bGwgfHwgcnZhbHVlID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBib3RoIHdlcmUgbnVsbCwgdGhleSdkIGhhdmUgYmVlbiA9PT1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGx2YWx1ZSk7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhydmFsdWUpLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIXJ2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKGtleSA9PT0gJ0RlcGVuZHNPbicpIHtcbiAgICAgICAgaWYgKCFkZXBlbmRzT25FcXVhbChsdmFsdWVba2V5XSwgcnZhbHVlW2tleV0pKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgLy8gY2hlY2sgZGlmZmVyZW5jZXMgb3RoZXIgdGhhbiBgRGVwZW5kc09uYFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGx2YWx1ZVtrZXldLCBydmFsdWVba2V5XSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIE5laXRoZXIgb2JqZWN0LCBub3IgYXJyYXk6IEkgZGVkdWNlIHRoaXMgaXMgcHJpbWl0aXZlIHR5cGVcbiAgLy8gUHJpbWl0aXZlIHR5cGUgYW5kIG5vdCA9PT0sIHNvIEkgZGVkdWNlIG5vdCBkZWVwRXF1YWxcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBhcmd1bWVudHMgdG8gRGVwZW5kc09uIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0gbHZhbHVlIHRoZSBsZWZ0IG9wZXJhbmQgb2YgdGhlIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gKiBAcGFyYW0gcnZhbHVlIHRoZSByaWdodCBvcGVyYW5kIG9mIHRoZSBlcXVhbGl0eSBjb21wYXJpc29uLlxuICpcbiAqIEByZXR1cm5zICt0cnVlKyBpZiBib3RoICtsdmFsdWUrIGFuZCArcnZhbHVlKyBhcmUgZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLlxuICovXG5mdW5jdGlvbiBkZXBlbmRzT25FcXVhbChsdmFsdWU6IGFueSwgcnZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgLy8gYWxsb3dzIFsnVmFsdWUnXSBhbmQgJ1ZhbHVlJyB0byBiZSBlcXVhbFxuICBpZiAoQXJyYXkuaXNBcnJheShsdmFsdWUpICE9PSBBcnJheS5pc0FycmF5KHJ2YWx1ZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmlzQXJyYXkobHZhbHVlKSA/IGx2YWx1ZSA6IHJ2YWx1ZTtcbiAgICBjb25zdCBub25BcnJheSA9IEFycmF5LmlzQXJyYXkobHZhbHVlKSA/IHJ2YWx1ZSA6IGx2YWx1ZTtcblxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEgJiYgZGVlcEVxdWFsKGFycmF5WzBdLCBub25BcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBhbGxvd3MgYXJyYXlzIHBhc3NlZCB0byBEZXBlbmRzT24gdG8gYmUgZXF1aXZhbGVudCBpcnJlc3BlY3RpdmUgb2YgZWxlbWVudCBvcmRlclxuICBpZiAoQXJyYXkuaXNBcnJheShsdmFsdWUpICYmIEFycmF5LmlzQXJyYXkocnZhbHVlKSkge1xuICAgIGlmIChsdmFsdWUubGVuZ3RoICE9PSBydmFsdWUubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAobGV0IGkgPSAwIDsgaSA8IGx2YWx1ZS5sZW5ndGggOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwIDsgaiA8IGx2YWx1ZS5sZW5ndGggOyBqKyspIHtcbiAgICAgICAgaWYgKCghZGVlcEVxdWFsKGx2YWx1ZVtpXSwgcnZhbHVlW2pdKSkgJiYgKGogPT09IGx2YWx1ZS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHJvZHVjZSB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gbWFwcywgYXMgYSBtYXAsIHVzaW5nIGEgc3BlY2lmaWVkIGRpZmYgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9sZFZhbHVlICB0aGUgb2xkIG1hcC5cbiAqIEBwYXJhbSBuZXdWYWx1ZSAgdGhlIG5ldyBtYXAuXG4gKiBAcGFyYW0gZWxlbWVudERpZmYgdGhlIGRpZmYgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMgYSBtYXAgcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuICtvbGRWYWx1ZSsgYW5kICtuZXdWYWx1ZSsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmS2V5ZWRFbnRpdGllczxUPihcbiAgb2xkVmFsdWU6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQsXG4gIG5ld1ZhbHVlOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHwgdW5kZWZpbmVkLFxuICBlbGVtZW50RGlmZjogKG9sZEVsZW1lbnQ6IGFueSwgbmV3RWxlbWVudDogYW55LCBrZXk6IHN0cmluZykgPT4gVCk6IHsgW25hbWU6IHN0cmluZ106IFQgfSB7XG4gIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogVCB9ID0ge307XG4gIGZvciAoY29uc3QgbG9naWNhbElkIG9mIHVuaW9uT2YoT2JqZWN0LmtleXMob2xkVmFsdWUgfHwge30pLCBPYmplY3Qua2V5cyhuZXdWYWx1ZSB8fCB7fSkpKSB7XG4gICAgY29uc3Qgb2xkRWxlbWVudCA9IG9sZFZhbHVlICYmIG9sZFZhbHVlW2xvZ2ljYWxJZF07XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5ld1ZhbHVlICYmIG5ld1ZhbHVlW2xvZ2ljYWxJZF07XG5cbiAgICBpZiAob2xkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIG5ld0VsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbiBpbiByZWFsaXR5LCBidXQgbWF5IGhhcHBlbiBpbiB0ZXN0cy4gU2tpcC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdFtsb2dpY2FsSWRdID0gZWxlbWVudERpZmYob2xkRWxlbWVudCwgbmV3RWxlbWVudCwgbG9naWNhbElkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB1bmlvbiBvZiB0d28gc2V0cyBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSBsdiB0aGUgbGVmdCBzZXQgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBydiB0aGUgcmlnaHQgc2V0IG9mIHN0cmluZ3MuXG4gKlxuICogQHJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyBhbGwgZWxlbWVidHMgZnJvbSArbHYrIGFuZCArcnYrLCB3aXRoIG5vIGR1cGxpY2F0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlvbk9mKGx2OiBzdHJpbmdbXSB8IFNldDxzdHJpbmc+LCBydjogc3RyaW5nW10gfCBTZXQ8c3RyaW5nPik6IHN0cmluZ1tdIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldChsdik7XG4gIGZvciAoY29uc3QgdiBvZiBydikge1xuICAgIHJlc3VsdC5hZGQodik7XG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheSguLi5yZXN1bHQpO1xufVxuXG4vKipcbiAqIEdldFN0YWNrVGVtcGxhdGUgZmxhdHRlbnMgYW55IGNvZGVwb2ludCBncmVhdGVyIHRoYW4gXCJcXHU3ZlwiIHRvIFwiP1wiLiBUaGlzIGlzXG4gKiB0cnVlIGV2ZW4gZm9yIGNvZGVwb2ludHMgaW4gdGhlIHN1cHBsZW1lbnRhbCBwbGFuZXMgd2hpY2ggYXJlIHJlcHJlc2VudGVkXG4gKiBpbiBKUyBhcyBzdXJyb2dhdGUgcGFpcnMsIGFsbCB0aGUgd2F5IHVwIHRvIFwiXFx1ezEwZmZmZn1cIi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIHNhbWUgbWFuZ2xpbmcgaW4gb3JkZXIgdG8gcHJvdmlkZSBkaWFnbm9zdGljXG4gKiBpbmZvcm1hdGlvbiBpbiBgY2RrIGRpZmZgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFuZ2xlTGlrZUNsb3VkRm9ybWF0aW9uKHBheWxvYWQ6IHN0cmluZykge1xuICByZXR1cm4gcGF5bG9hZC5yZXBsYWNlKC9bXFx1ezgwfS1cXHV7MTBmZmZmfV0vZ3UsICc/Jyk7XG59XG5cbi8qKlxuICogQSBwYXJzZUZsb2F0IGltcGxlbWVudGF0aW9uIHRoYXQgZG9lcyB0aGUgcmlnaHQgdGhpbmcgZm9yXG4gKiBzdHJpbmdzIGxpa2UgJzAuMC4wJ1xuICogKGZvciB3aGljaCBKYXZhU2NyaXB0J3MgcGFyc2VGbG9hdCgpIHJldHVybnMgMCkuXG4gKiBXZSByZXR1cm4gTmFOIGZvciBhbGwgb2YgdGhlc2Ugc3RyaW5ncyB0aGF0IGRvIG5vdCByZXByZXNlbnQgbnVtYmVycyxcbiAqIGFuZCBzbyBjb21wYXJpbmcgdGhlbSBmYWlscyxcbiAqIGFuZCBkb2Vzbid0IHNob3J0LWNpcmN1aXQgdGhlIGRpZmYgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVQYXJzZUZsb2F0KHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIE51bWJlcihzdHIpO1xufVxuXG4vKipcbiAqIExhemlseSBsb2FkIHRoZSBzZXJ2aWNlIHNwZWMgZGF0YWJhc2UgYW5kIGNhY2hlIHRoZSBsb2FkZWQgZGJcbiovXG5sZXQgREFUQUJBU0U6IFNwZWNEYXRhYmFzZSB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGRhdGFiYXNlKCk6IFNwZWNEYXRhYmFzZSB7XG4gIGlmICghREFUQUJBU0UpIHtcbiAgICBEQVRBQkFTRSA9IGxvYWRBd3NTZXJ2aWNlU3BlY1N5bmMoKTtcbiAgfVxuICByZXR1cm4gREFUQUJBU0U7XG59XG5cbi8qKlxuICogTG9hZCBhIFJlc291cmNlIG1vZGVsIGZyb20gdGhlIFNlcnZpY2UgU3BlYyBEYXRhYmFzZVxuICpcbiAqIFRoZSBkYXRhYmFzZSBpcyBsb2FkZWQgbGF6aWx5IGFuZCBjYWNoZWQgYWNyb3NzIG11bHRpcGxlIGNhbGxzIHRvIGBsb2FkUmVzb3VyY2VNb2RlbGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVzb3VyY2VNb2RlbCh0eXBlOiBzdHJpbmcpOiBSZXNvdXJjZSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBkYXRhYmFzZSgpLmxvb2t1cCgncmVzb3VyY2UnLCAnY2xvdWRGb3JtYXRpb25UeXBlJywgJ2VxdWFscycsIHR5cGUpLmF0KDApO1xufVxuIl19